java常用类库及技巧
	java异常
		什么被抛出
		在哪被抛出
		为什么抛出
	erro
		系统致命错误，程序无法处理的，编译器不做检查
		例如：系统错误、虚拟机崩溃、栈溢出、内存空间不足
	exception
		系统可以处理的异常，抓到后可以恢复
		RunTimeException
			运行时异常，不可预知的，程序应当自行避免
				空指针、类转换、非法参数、下标越界、数字格式
		非RunTimeException
			非运行时异常，可预知的，编译器校验的异常 可检查的，我们用try  catch处理一下
			不要泛化异常
				类找不到、IO操作异常
	处理异常的方式
		抛出异常throw
            throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结 束当前方法的执行
			if(workerId ==null){
				throw new ServiceException(ExtendedErrorCode.E201.code(), "请确保选中护工");//方法内执行，执行到这里，停掉了，给接口调用者提示“请确保选中护工”
			}
		声明抛出异常throws
			运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常
		try catch  ---影响jvm的优化
			try {
			   ...  //监视代码执行过程，一旦返现异常则直接跳转至catch，
					// 如果没有异常则直接跳转至finally
			} catch (SomeException e) {
				... //可选执行的代码块，如果没有任何异常发生则不会执行；
					//如果发现异常则进行处理或向上抛出。
			} finally {
				... //必选执行的代码块，不管是否有异常发生，
					// 即使发生内存溢出异常也会执行，通常用于处理善后清理工作。
			}
		trycatch 性能较差，且异常对象实例需要保存栈快照信息，开销较大
		精准定位所要抓住的异常、不要使用trycatch去处理大段代码可以换用ifelse等等
java集合
	Collerction
		list---有序、可重复、可通过索引操作元素
			底层数组--查询快，增删慢
				Arraylist--线程不安全，效率高
				Vector--线程安全，效率低
			底层链表--查询慢，增删快
				linkedList--线程不安全，效率高
		set---无序，且元素不可重复
			底层哈希
				hashset 保证元素的唯一性 hashcode和equals
			底层二叉树
				考虑排序用treeset
					自身类实现的comparable接口
					比较器接口的comparable接口
	map
		HashMap
			键值对映射   java8以前采用的是数组加链表
			通过hashcode的取模运算算出数据存放的位置，然后该位置存放的是链表的头指针
			极端情况，多次取模运算得到的数据存放位置是同一个会照成对应的链表特别长，而链表查询数据都是从头开始，所以会使得复杂度很高
			当链表的数据长度达到8的时候就会被树化，如果数组长度在动态操作过程中长度小于6则会重新转成链表
				put方法逻辑
					初始化hashmap--对key求hash值，然后计算下标--如果没有碰撞直接放入桶中--如果碰撞了就以链表的方式放在桶的后面-->8转红黑树 <6转链表--覆盖旧值--桶的容量满了（16*0.75），就需要resize且扩容重排。
				如何减少碰撞
					扰动函数
					使用final常量，或者重写了hash和equals方法
				扩容带来的问题
					多线程下，容易死锁
					扩容移位耗时时间长
		HashTable  线程安全 数组加链表 锁住整个对象
			Collections.synchronizedMap(hashMap);//加锁安全后的map
			
			如何优化hashtable
				通过锁的细粒度化，将整个锁拆分出多个锁进行优化
				早期的ConccurentHashMap就是通过的分段锁的方式，数组加链表 锁在数组中，数据在链表中，实例可拿其中一段锁，不影响其他实例拿其他段的锁
				java8 CAS+synchronized使锁细粒度化，之锁定首节点
				ConccurentHashMap的put方法逻辑
					检查node数组是否初始化--通过hash定位数组的索引坐标，观察是否有node节点，如果没有则CAS进行添加，添加失败则进入下一次循环--检查到内部扩容则帮助扩容--如果头部有元素就锁住元素
juc包梳理
	简书
		volatile关键字与内存可见性---一个线程改变了一个共享数据，但是没有及时刷新到内存中，导致另外一个线程进来时看到还是老数据
		解决方式
			加锁--可以解决但是存在问题---每次只能有一个线程访问，当一个线程持有锁时，其他的就会阻塞，效率就非常低了
			volatile--当多个线程操作共享数据时，可以保证内存中的数据可见。用这个关键字修饰共享数据，就会及时的把线程缓存中的数据刷新到主存中去，也可以理解为，就是直接操作主存中的数据
		volatile和synchronized的区别：
			volatile不具备互斥性(当一个线程持有锁时，其他线程进不来，这就是互斥性)。
			volatile不具备原子性。
							
	



